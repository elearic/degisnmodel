代理模式 (结构型模式)

Proxy Pattern


是指为其他对象提供一种代理, 以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端
和目标对象之间起到中介的作用。


代理模式一般包含三种角色

抽象主题角色（Subject）: 抽象主题类的主要职责是声明真实主题与代理的共同接口方法，该类可以是接口也可以是抽象类。

真实主题角色（RealSubject) : 该类也被称为被代理类，该类定义了代理所表示的真实对象，是负责执行系统真正的逻辑业务对象。

代理主题角色 (Proxy): 也被称为代理类，其内部持有RealSubject的引用，因此具备完全的对RealSubject的代理权。客户端调用代理对象的方法，
同时也调用被代理对象的方法，但是会对代理对象增强(会在代理对象前后增加一些处理对象)



应用场景：

    生活中的租房中介、售票黄牛、婚介、经纪人、快递、事务代理、非侵入式日志监听等，都是代理模式的实际体现。当无法或不想直接引用某个对象
    或访问某个对象存在困难时，可以通过代理对象间接访问。



使用代理模式主要有连个目的：意识保护目标对象，二是增强目标对象。



//JDK是采用读取接口的信息
//CGLib覆盖父类方法
//目的：都是生成一个新的类，去实现增强代码逻辑的功能

//JDK Proxy 对于用户而言，必须要有一个接口实现，目标类相对来说复杂
//CGLib 可以代理任意一个普通的类，没有任何要求

//CGLib 生成代理逻辑更复杂，效率,调用效率更高，生成一个包含了所有的逻辑的FastClass，不再需要反射调用
//JDK Proxy生成代理的逻辑简单，执行效率相对要低，每次都要反射动态调用

//CGLib 有个坑，CGLib不能代理final的方法